import numpy as np


class PairwiseGibbs:
    """
    A sampler that generates samples that roughly follow a multivariate Bernoulli distribution. The behaviour is
    similar to a Gibbs sampler, but rather than considering P(s_new | s_0, ..., s_n) it only considers P(s_new|s_n),
    where n is the index of the last selected state. In other words, it procedurally generates state sequences by
    considering the conditional probability only given the last sampled state.
    """

    def __init__(self, means, covariance_matrices):
        """
        Initializes the PairwiseGibbs.

        Parameters:
        means (array-like): The means of the distribution. Shape: batch x len(s)
        covariance_matrices (array-like): The covariance matrix. Shape: batch x len(s) x len(s)
        """

        # TODO: find smart way to process 3d matrices. For now processing only happens on an 1-by-1 basis
        # assert len(means.shape)==2
        # assert len(covariance_matrices.shape)==3
        self.means = means
        self.covariance_matrices = covariance_matrices

        # Convert covariance matrix to correlation matrix # todo: find a good way to produce the correlation matrix
        self.correlation_matrices = [
            self.C2R(covariance_matrix) for covariance_matrix in covariance_matrices
        ]

        # TODO: verify accuracy AFTER a program is built to do it.
        self.conditional_probabilities = np.zeros_like(self.correlation_matrix)
        for i in range(len(self.correlation_matrix)):
            for j in range(len(self.correlation_matrix)):
                if i == j:
                    self.conditional_probabilities[i, j] = 0
                else:
                    self.conditional_probabilities[i, j] = (
                        self.correlation_matrix[i, j] / np.sum(self.correlation_matrix[i])
                        - self.correlation_matrix[i, i]
                    )

        # Calculate seed probability
        self.seed_probability = self.means / np.sum(self.means)

        # Decide how many bits to select # todo: find a way to compute M. Alternatively, find a way to
        expected_value = np.sum(self.means)
        variance_of_expected_value = (
            np.sum(np.diag(self.covariance_matrices))
            + 2 * np.sum(self.covariance_matrices)
            - 2 * np.sum(np.outer(self.means, self.means))
        )

    def sample(self):
        # TODO: DO NOT FIND A SMARTER WAY TO DO THIS
        """
        Generates a sample using the custom sampler.

        Returns:
        array: A sample generated by the custom sampler.
        """
        # Select first state
        s0 = np.random.choice(len(self.means), p=self.seed_probability)
        samples = [s0]

        # Do M-1 loops
        for i in range(self.M - 1):
            conditional_probability_vector = self.conditional_probabilities[s0]
            s1 = np.random.choice(len(self.means), p=conditional_probability_vector)
            samples.append(s1)
            s0 = s1

        return np.array(samples)

    def correlation_from_covariance(self, covariance_matrix):
        v = np.sqrt(np.diag(covariance_matrix))
        outer_v = np.outer(v, v)
        correlation = covariance_matrix / outer_v
        correlation[covariance_matrix == 0] = 0
        return correlation

    def C2R(self, covariance_matrix):
        return self.correlation_from_covariance(covariance_matrix)
